/*

Computes the Rényi entropy of a an interval in 
the ground state of a quadratic, translational
invariant Hamiltonian 

*/

/*

 We diagonalise the correlation matrix 
 2<(a_n, a_n^dagger)^t(a_m^dagger, a_m)>-\delta_{nm} 

*/

/*

 We computed a row of this matrix in the Mathematica notebook
"math_moebius"

*/

/*

To compile write: 
gcc -L/usr/local/lib moebius.c -o moebius -lgsl -lgslcblas -lm

*/

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<gsl/gsl_complex_math.h>
#include<gsl/gsl_complex.h>
#include<gsl/gsl_eigen.h>
#include<gsl/gsl_math.h>
#include<gsl/gsl_matrix.h>

FILE *out;

double S, Salpha; /*S is the von Neumann entropy and
                    Salpha is the Rényi entropy of parameter alpha*/

float zeta, alpha; /*zeta is the SO(1,1) parameter and 
                         alpha is the Rényi parameter*/
int l; /*Length of the interval*/

void load_correl(gsl_matrix_complex *correl, double **f12, double **f22);
void compute_eigenvalues(gsl_matrix_complex *correl, double *eigen);
void compute_entropy(double *eigen);
void write_results();



void main(int argc, char *argv[])
{
 int i;
 char name_file[256];
 
 if(argc==4)
    {
      sscanf(argv[1], "%d", &l);
      sscanf(argv[2], "%f", &zeta);
      sscanf(argv[3], "%f", &alpha);
    }

  else
    {
      printf("Some parameters are left...\n");
      exit(0);
    }
 
  /*f1 corresponds to the row of the matrix generated by the entries 
    G_00 y G_01 of the symbol*/
  /*f2 corresponds to the row of the matrix generated by the entries 
    G_10 y G_11 of the symbol*/

  double **f1, **f2;

  f1=malloc(2*l*sizeof(int *)); 

  for (i= 0; i < 2*l; i++)     
    f1[i] = malloc(2*sizeof(int));
  
  f2=malloc(2*l*sizeof(int *)); 
  
  for (i= 0; i < 2*l; i++)     
    f2[i] = malloc(2*sizeof(int));
 
  sprintf(name_file, "moebius_correl.dat");
  
  out=fopen(name_file, "rt");
  for(i=0; i<2*l; i=i+2)
   {
    
    fscanf(out,"%lf %lf %lf %lf %lf %lf %lf %lf \n", 
     &f1[i][1], &f1[i][2], &f1[i+1][1], &f1[i+1][2], 
     &f2[i][1], &f2[i][2], &f2[i+1][1], &f2[i+1][2]);
     
   }  
  
  fclose(out);
  
  double *eigen=malloc(2*l*sizeof(double));
  
  gsl_matrix_complex *correl=gsl_matrix_complex_alloc(2*l, 2*l);
    
  load_correl(correl, f1, f2);
  compute_eigenvalues(correl, eigen);
  compute_entropy(eigen); 
  write_results();
      
  free(eigen);
  gsl_matrix_complex_free(correl);

  free(f1);
  free(f2);
}
   
void load_correl(gsl_matrix_complex *correl, double **f1, double **f2) 
{
   int n, m, p;
   gsl_complex z, w;

  /*We build the upper triangular part of the correlacion matrix*/ 

   for(n=0; n<2*l; n=n+2)
    {
     for(m=n; m<2*l; m++)
      {
        GSL_SET_COMPLEX(&z, f1[m-n][1], f1[m-n][2]); 
        gsl_matrix_complex_set(correl, n, m, z); 
        GSL_SET_COMPLEX(&z, f2[m-n][1], f2[m-n][2]); 
        gsl_matrix_complex_set(correl, n+1, m, z);   
       }
     }

 /*We build the lower triangular part of the correlation matrix
   taking into account that it is Hermitian*/
    
 for(m=0; m<2*l; m=m+2)
  {
   for(n=m+2; n<2*l; n++)
    {
      gsl_matrix_complex_set(correl, n, m, 
                 gsl_complex_conjugate(gsl_matrix_complex_get(correl, m, n)));
      gsl_matrix_complex_set(correl, n, m+1, 
                 gsl_complex_conjugate(gsl_matrix_complex_get(correl, m+1, n)));          
    }
  }
}
void compute_eigenvalues(gsl_matrix_complex *correl, double *eigen)
{
  int i;

  gsl_eigen_herm_workspace *w=gsl_eigen_herm_alloc(2*l);
  gsl_vector *eigen2=gsl_vector_alloc(2*l);
  gsl_eigen_herm(correl, eigen2, w);

  for(i=0; i<2*l; i++)
      eigen[i]=gsl_vector_get(eigen2, i);
     
  
  gsl_vector_free(eigen2);
  gsl_eigen_herm_free(w);
}

void compute_entropy(double *eigen)
{
  int i;
  
  S=0;

  for(i=0; i<2*l; i++)
    {
      if(fabs(eigen[i])>=1.0) //0.9999
	   S+=0;
      else
        S+=-(0.5*(1+fabs(eigen[i]))*log(0.5*(1+fabs(eigen[i])))
             +0.5*(1-fabs(eigen[i]))*log(0.5*(1-fabs(eigen[i])))); 
        Salpha+= 1/(1-alpha)*log(pow(0.5*(1+eigen[i]), alpha)
                                 +pow(0.5*(1-eigen[i]), alpha));
       
    }

  S=0.5*S;
  Salpha= 0.5*Salpha;

  printf("S=%lf\n", S);
}
 
void write_results()
{
  char name_file[256];

  sprintf(name_file, "moebius_entropy_%1.2f_l_%d.dat", alpha, l);
  out=fopen(name_file, "at");
  fprintf(out,"%1.2f %.10lf %.10lf \n", zeta, S, Salpha);
  fclose(out);
}  
