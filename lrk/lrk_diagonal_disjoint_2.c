/*

 It computes the Rényi entropy for two disjoint 
 intervals in the ground state of a quadratic, 
 translational invariant Hamiltonian 

*/

/*

 We diagonalise the correlation matrix 
 2<(a_n, a_n^dagger)^t(a_m^dagger, a_m)>-\delta_{nm} 
 using the GSL library

*/

/*

 It reads from a file the entries of a row of this 
 matrix computed with the Mathematica notebook "math_moebius"

*/

/*

 To compile write: 
 gcc -L/usr/local/lib moebius.c -o moebius -lgsl -lgslcblas -lm

*/

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<gsl/gsl_complex_math.h>
#include<gsl/gsl_complex.h>
#include<gsl/gsl_eigen.h>
#include<gsl/gsl_math.h>
#include<gsl/gsl_matrix.h>

FILE *out;

double S, Salpha; /*S is the von Neumann entropy and
                    Salpha is the Rényi entropy of parameter alpha*/

float delta, h,  alpha; /*delta and h are the coupling constants of the theory 
                          and alpha is the Rényi parameter*/

int l1, l2, d, delta_d, d_max; /*Length of the intervals and separation between 
                                 them*/

void load_submatrix_correl(gsl_matrix_complex *correl);
void compute_eigenvalues(gsl_matrix_complex *correl, double *eigen);
void compute_entropy(double *eigen);
void write_results();


void main(int argc, char *argv[])
{ 
 if(argc==9)
    {
      sscanf(argv[1], "%d", &l1);
      sscanf(argv[2], "%d", &d);
      sscanf(argv[3], "%d", &l2);      
      sscanf(argv[4], "%d", &d_max);
      sscanf(argv[5], "%d", &delta_d);
      sscanf(argv[6], "%f", &delta);
      sscanf(argv[7], "%f", &h);
      sscanf(argv[8], "%f", &alpha);
    }

 else
    {
      printf("Some parameters are left...\n");
      exit(0);
    }
 
 gsl_matrix_complex *correl=gsl_matrix_complex_alloc(2*(l1+l2), 
                                             2*(l1+l2)); /*Correlation matrix*/
 double *eigen=malloc(2*(l1+l2)*sizeof(double)); /*Eigenvalues of the 
                                                      correlation matrix*/
 while (d <= d_max)
  {
   printf("d=%d\n", d);
   
  
   load_submatrix_correl(correl);
   compute_eigenvalues(correl, eigen);
   compute_entropy(eigen); 
   write_results();
      
   d+=delta_d;
  }
 
 free(eigen);
 gsl_matrix_complex_free(correl);
}
   
void load_submatrix_correl(gsl_matrix_complex *correl) 
{
 int n, m;
 gsl_complex z, w;
 char name_file[256];
 
 /*We read the row of the correlation matrix from the file*/

 /*f1 corresponds to the row of the matrix generated by the entries 
     G_00 y G_01 of the symbol*/
 /*f2 corresponds to the row of the matrix generated by the entries 
     G_10 y G_11 of the symbol*/

 double **f1, **f2;

 f1=malloc(2*(l1+d+l2)*sizeof(int *)); 

 for (n= 0; n < 2*(l1+d+l2); n++)     
      f1[n] = malloc(2*sizeof(int));
  
 f2=malloc(2*(l1+d+l2)*sizeof(int *)); 
  
 for (n= 0; n < 2*(l1+d+l2); n++)     
      f2[n] = malloc(2*sizeof(int));
 

 sprintf(name_file, "lrk_correl.dat");
 out=fopen(name_file, "rt");

 for(n=0; n<2*(l1+d+l2); n=n+2)
   {
    fscanf(out,"%lf %lf %lf %lf %lf %lf %lf %lf \n", 
      &f1[n][1], &f1[n][2], &f1[n+1][1], &f1[n+1][2], 
      &f2[n][1], &f2[n][2], &f2[n+1][1], &f2[n+1][2]);
   }  
  
 fclose(out);
 
 /*Block: (1,l1)-(1,l1)*/

 /*We construct the upper triangular part of the block*/ 

 for(n=0; n<2*l1; n=n+2)
   {
    for(m=n; m<2*l1; m++)
      {
       GSL_SET_COMPLEX(&z, f1[abs(m-n)][1], f1[abs(m-n)][2]); 
       gsl_matrix_complex_set(correl, n, m, z); 
       GSL_SET_COMPLEX(&z, f2[abs(m-n)][1], f2[abs(m-n)][2]); 
       gsl_matrix_complex_set(correl, n+1, m, z);
      }
    }

 /*We build the lower triangular part of the block*/
    
 for(m=0; m<2*l1; m=m+2)
   {
    for(n=m+2; n<2*l1; n++)
      {
       gsl_matrix_complex_set(correl, n, m, 
           gsl_complex_conjugate(gsl_matrix_complex_get(correl, m, n)));
       gsl_matrix_complex_set(correl, n, m+1, 
           gsl_complex_conjugate(gsl_matrix_complex_get(correl, m+1, n)));
      }
   }

 /*Block: (l1+d+1,l1+d+l2)-(l1+d+1,l1+d+l2)*/

 /*We construct the upper triangular part of the block*/ 

  for(n=2*l1; n<2*(l1+l2); n=n+2)
   {
    for(m=n; m<2*(l1+l2); m++)
      {
	GSL_SET_COMPLEX(&z, f1[abs(m-n)][1], f1[abs(m-n)][2]); 
       gsl_matrix_complex_set(correl, n, m, z); 
       GSL_SET_COMPLEX(&z, f2[abs(m-n)][1], f2[abs(m-n)][2]); 
       gsl_matrix_complex_set(correl, n+1, m, z);   
      }
    }

 /*We build the lower triangular part of the block*/
    
 for(m=2*l1; m<2*(l1+l2); m=m+2)
   {
    for(n=m+2; n<2*(l1+l2); n++)
      {
       gsl_matrix_complex_set(correl, n, m, 
           gsl_complex_conjugate(gsl_matrix_complex_get(correl, m, n)));
       gsl_matrix_complex_set(correl, n, m+1, 
           gsl_complex_conjugate(gsl_matrix_complex_get(correl, m+1, n)));         
      }
   }
 
 /*Blocks: (1,l1)-(l1+d+1,l1+d+l2) and (l1+d,l1+d+l2)-(1,l1)*/

  for(n=0; n<2*l1; n=n+2)
   {
     for(m=2*(l1+d); m<2*(l1+d+l2); m++)
      {
       GSL_SET_COMPLEX(&z, f1[abs(m-n)][1], f1[abs(m-n)][2]); 
       gsl_matrix_complex_set(correl, n, m-2*d, z); 
       GSL_SET_COMPLEX(&z, f2[abs(m-n)][1], f2[abs(m-n)][2]); 
       gsl_matrix_complex_set(correl, n+1, m-2*d, z);   
       GSL_SET_COMPLEX(&z, f1[abs(m-n)][1], -f1[abs(m-n)][2]); 
       gsl_matrix_complex_set(correl, m-2*d, n, z); 
       GSL_SET_COMPLEX(&z, f2[abs(m-n)][1], -f2[abs(m-n)][2]); 
       gsl_matrix_complex_set(correl, m-2*d, n+1, z);      
     }
    }
  
 free(f1);
 free(f2);   
}


void compute_eigenvalues(gsl_matrix_complex *correl, double *eigen)
{
 int n;
 gsl_eigen_herm_workspace *w=gsl_eigen_herm_alloc(2*(l1+l2));
 gsl_vector *eigen2=gsl_vector_alloc(2*(l1+l2));

 gsl_eigen_herm(correl, eigen2, w);

 for(n=0; n<2*(l1+l2); n++)
      eigen[n]=gsl_vector_get(eigen2, n);

 gsl_vector_free(eigen2);
 gsl_eigen_herm_free(w);
}

void compute_entropy(double *eigen)
{
 int n;

 S=0;
 Salpha=0;

 for(n=0; n<2*(l1+l2); n++)
   {
    if(fabs(eigen[n])>=1.0)
      {
       S+=0;
       Salpha+=0;
      }	   
    else
      {
	S+=-(0.5*(1+eigen[n])*log(0.5*(1+eigen[n]))
             +0.5*(1-eigen[n])*log(0.5*(1-eigen[n]))); 

	Salpha+= 1/(1-alpha)*log(pow(0.5*(1+eigen[n]), alpha)
                                 +pow(0.5*(1-eigen[n]), alpha));
      }
    }

  S=0.5*S;
  Salpha= 0.5*Salpha;

  printf("S=%lf\n", S);
}
 
void write_results()
{
  char name_file[256];

  sprintf(name_file, "lrk_entropy_disjoint_2_%1.2f_d_%1.2f_h_%1.2f.dat", 
                                                               alpha, delta, h);
  out=fopen(name_file, "at");
  fprintf(out,"%d %d %d %.10lf %.10lf \n", l1, d, l2, S, Salpha);
  fclose(out);
}  
